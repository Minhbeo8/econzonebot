import nextcord
from nextcord.ext import commands
import logging
from typing import Optional, Union
import json
from datetime import datetime, timedelta
from rapidfuzz import fuzz
logger = logging.getLogger(__name__)

async def try_send(
    ctx: Union[commands.Context, nextcord.Interaction],
    content: Optional[str] = None,
    embed: Optional[nextcord.Embed] = None,
    view: Optional[nextcord.ui.View] = None,
    ephemeral: bool = False
) -> Optional[nextcord.Message]:
    """
    C·ªë g·∫Øng g·ª≠i tin nh·∫Øn. Tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng tin nh·∫Øn n·∫øu th√†nh c√¥ng, None n·∫øu th·∫•t b·∫°i.
    H·ªó tr·ª£ c·∫£ l·ªánh prefix v√† l·ªánh slash.
    """
    send_method = None
    if isinstance(ctx, commands.Context):
        send_method = ctx.send
    elif isinstance(ctx, nextcord.Interaction):
        # Ki·ªÉm tra xem interaction ƒë√£ ƒë∆∞·ª£c tr·∫£ l·ªùi ch∆∞a
        if ctx.response.is_done():
            send_method = ctx.followup.send
        else:
            send_method = ctx.response.send_message

    if not send_method:
        logger.error(f"Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ph∆∞∆°ng th·ª©c g·ª≠i cho context lo·∫°i: {type(ctx)}")
        return None

    try:
        # L·ªánh slash c√≥ tham s·ªë ephemeral
        if isinstance(ctx, nextcord.Interaction) and ephemeral:
            return await send_method(content=content, embed=embed, view=view, ephemeral=True)
        else:
            return await send_method(content=content, embed=embed, view=view)
    except nextcord.errors.NotFound:
        logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn: Interaction ho·∫∑c Context kh√¥ng c√≤n t·ªìn t·∫°i.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i tin nh·∫Øn: {e}", exc_info=True)
    return None

def format_large_number(number: int) -> str:
    """ƒê·ªãnh d·∫°ng s·ªë l·ªõn v·ªõi d·∫•u ph·∫©y."""
    return "{:,}".format(number)

def get_player_title(local_level: int, wanted_level: float) -> str:
    """
    T·∫°o danh hi·ªáu cho ng∆∞·ªùi ch∆°i d·ª±a tr√™n c√°c ch·ªâ s·ªë ƒë∆∞·ª£c truy·ªÅn v√†o.
    """
    if wanted_level > 20: return "üî• B·ªã Truy N√£ G·∫Øt Gao"
    if wanted_level > 10: return "ü©∏ T·ªôi Ph·∫°m Kh√©t Ti·∫øng"
    if wanted_level > 5: return "üíÄ K·∫ª Ngo√†i V√≤ng Ph√°p Lu·∫≠t"
    if local_level > 50: return "üíé Huy·ªÅn Tho·∫°i S·ªëng"
    if local_level > 30: return "üèÜ L√£o L√†ng"
    if local_level > 15: return "ü•á D√¢n Ch∆°i"
    return "üå± T·∫•m Chi·∫øu M·ªõi"
def load_activities_data():
    """T·∫£i d·ªØ li·ªáu ho·∫°t ƒë·ªông t·ª´ file activities.json."""
    try:
        
        activities_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'activities.json')
        with open(activities_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print("L·ªñI: kh√¥ng t√¨m th·∫•y file activities.json.")
        return None
    except json.JSONDecodeError:
        print("L·ªñI: file activities.json c√≥ ƒë·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá.")
        return None
def format_relative_timestamp(future_timestamp: float) -> str:
    """
    Chuy·ªÉn ƒë·ªïi m·ªôt timestamp trong t∆∞∆°ng lai th√†nh ƒë·ªãnh d·∫°ng timestamp t∆∞∆°ng ƒë·ªëi c·ªßa Discord.
    V√≠ d·ª•: <t:1678886400:R> s·∫Ω hi·ªÉn th·ªã l√† "in 2 hours".
    """
    return f"<t:{int(future_timestamp)}:R>"

def require_travel_check(func):
    """
    Decorator ƒë·ªÉ ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ ƒëang trong tr·∫°ng th√°i 'di chuy·ªÉn' hay kh√¥ng.
    """
    async def wrapper(self, ctx: commands.Context, *args, **kwargs):        
        await func(self, ctx, *args, **kwargs)
    return wrapper
def find_best_match(query: str, choices: list, score_cutoff: int = 75) -> Optional[str]:
    """
    T√¨m chu·ªói g·∫ßn ƒë√∫ng nh·∫•t trong m·ªôt danh s√°ch.
    Tr·∫£ v·ªÅ chu·ªói ph√π h·ª£p nh·∫•t n·∫øu ƒë·ªô t∆∞∆°ng ƒë·ªìng > score_cutoff, ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ None.
    """
    best_match = process.extractOne(query, choices, score_cutoff=score_cutoff)
    if best_match:
        return best_match[0]
    return None
